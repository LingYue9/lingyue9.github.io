{"title":"翎月的博客","description":"","language":"","link":"https://lingyue9.github.io","pubDate":"Wed, 10 Apr 2019 02:30:24 GMT","lastBuildDate":"Wed, 23 Sep 2020 16:09:41 GMT","generator":"hexo-generator-json-feed","webMaster":"翎月","items":[{"title":"Java反射","link":"https://lingyue9.github.io/2019/04/10/Java反射/","description":"定义JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 用途在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到通过反射得到的结果与预期不符。而后阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。 反射机制的相关类与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类的相关方法 方法 用途 asSubclass(Class\\ clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或接口的对象 getClassLoader() 获得类的加载器 getClasser() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class\\ annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类中所有公有注解对象 getDeclaredAnnotation(Class\\ annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 Field类Field代表类的成员变量（类的属性）。 方法 用途 eauals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类Method代表类的方法 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类Constructor代表类的构造方法 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 示例为了演示反射的使用，首先构造一个与书籍相关的model——Book.java，然后通过反射方法示例创建对象、反射私有构造方法、反射私有属性、反射私有方法，最后给出两个比较复杂的反射示例——获得当前ZenMode和关机Shutdown。 被反射类Book.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Book &#123; private final static String TAG = \"BookTag\"; private String name; private String author; @Override public String toString() &#123; return \"Book&#123;\" + \"name='\" + name + '\\'' + \", author='\" + author + '\\'' + '&#125;'; &#125; public Book() &#123; &#125; private Book(String name, String author) &#123; this.name = name; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; private String declaredMethod(int index) &#123; String string = null; switch (index) &#123; case 0: string = \"I am declaredMethod 1 !\"; break; case 1: string = \"I am declaredMethod 2 !\"; break; default: string = \"I am declaredMethod 1 !\"; &#125; return string; &#125;&#125; 反射逻辑封装在ReflectClass.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class ReflectClass &#123; private final static String TAG = \"peter.log.ReflectClass\"; // 创建对象 public static void reflectNewInstance() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Book book = (Book) objectBook; book.setName(\"Android进阶之光\"); book.setAuthor(\"刘望舒\"); Log.d(TAG,\"reflectNewInstance book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有的构造方法 public static void reflectPrivateConstructor() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Constructor&lt;?&gt; declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class); declaredConstructorBook.setAccessible(true); Object objectBook = declaredConstructorBook.newInstance(\"Android开发艺术探索\",\"任玉刚\"); Book book = (Book) objectBook; Log.d(TAG,\"reflectPrivateConstructor book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有属性 public static void reflectPrivateField() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Field fieldTag = classBook.getDeclaredField(\"TAG\"); fieldTag.setAccessible(true); String tag = (String) fieldTag.get(objectBook); Log.d(TAG,\"reflectPrivateField tag = \" + tag); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有方法 public static void reflectPrivateMethod() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Method methodBook = classBook.getDeclaredMethod(\"declaredMethod\",int.class); methodBook.setAccessible(true); Object objectBook = classBook.newInstance(); String string = (String) methodBook.invoke(objectBook,0); Log.d(TAG,\"reflectPrivateMethod string = \" + string); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 获得系统Zenmode值 public static int getZenMode() &#123; int zenMode = -1; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\", String.class); Object oNotificationManagerService = mGetService.invoke(null, Context.NOTIFICATION_SERVICE); Class&lt;?&gt; cINotificationManagerStub = Class.forName(\"android.app.INotificationManager$Stub\"); Method mAsInterface = cINotificationManagerStub.getMethod(\"asInterface\",IBinder.class); Object oINotificationManager = mAsInterface.invoke(null,oNotificationManagerService); Method mGetZenMode = cINotificationManagerStub.getMethod(\"getZenMode\"); zenMode = (int) mGetZenMode.invoke(oINotificationManager); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return zenMode; &#125; // 关闭手机 public static void shutDown() &#123; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\",String.class); Object oPowerManagerService = mGetService.invoke(null,Context.POWER_SERVICE); Class&lt;?&gt; cIPowerManagerStub = Class.forName(\"android.os.IPowerManager$Stub\"); Method mShutdown = cIPowerManagerStub.getMethod(\"shutdown\",boolean.class,String.class,boolean.class); Method mAsInterface = cIPowerManagerStub.getMethod(\"asInterface\",IBinder.class); Object oIPowerManager = mAsInterface.invoke(null,oPowerManagerService); mShutdown.invoke(oIPowerManager,true,null,true); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; public static void shutdownOrReboot(final boolean shutdown, final boolean confirm) &#123; try &#123; Class&lt;?&gt; ServiceManager = Class.forName(\"android.os.ServiceManager\"); // 获得ServiceManager的getService方法 Method getService = ServiceManager.getMethod(\"getService\", java.lang.String.class); // 调用getService获取RemoteService Object oRemoteService = getService.invoke(null, Context.POWER_SERVICE); // 获得IPowerManager.Stub类 Class&lt;?&gt; cStub = Class.forName(\"android.os.IPowerManager$Stub\"); // 获得asInterface方法 Method asInterface = cStub.getMethod(\"asInterface\", android.os.IBinder.class); // 调用asInterface方法获取IPowerManager对象 Object oIPowerManager = asInterface.invoke(null, oRemoteService); if (shutdown) &#123; // 获得shutdown()方法 Method shutdownMethod = oIPowerManager.getClass().getMethod( \"shutdown\", boolean.class, String.class, boolean.class); // 调用shutdown()方法 shutdownMethod.invoke(oIPowerManager, confirm, null, false); &#125; else &#123; // 获得reboot()方法 Method rebootMethod = oIPowerManager.getClass().getMethod(\"reboot\", boolean.class, String.class, boolean.class); // 调用reboot()方法 rebootMethod.invoke(oIPowerManager, confirm, null, false); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 调用相应反射逻辑方法 1234567891011121314151617try &#123; // 创建对象 ReflectClass.reflectNewInstance(); // 反射私有的构造方法 ReflectClass.reflectPrivateConstructor(); // 反射私有属性 ReflectClass.reflectPrivateField(); // 反射私有方法 ReflectClass.reflectPrivateMethod();&#125; catch (Exception ex) &#123; ex.printStackTrace();&#125;Log.d(TAG,\" zenmode = \" + ReflectClass.getZenMode()); 总结本文列举了反射机制使用过程中常用的、重要的一些类及其方法，更多信息和用法需要近一步的阅读Google提供的相关文档和示例。 在阅读Class类文档时发现一个特点，以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。getMethod(parameterTypes)用来获取某个公有的方法的对象，getMethods()获得该类所有公有的方法，getDeclaredMethod(parameterTypes)获得该类某个方法，getDeclaredMethods()获得该类所有方法。带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。其他的Annotation、Field、Constructor也是如此。 在ReflectClass类中还提供了两种反射PowerManager.shutdown()的方法，在调用的时候会输出如下log，提示没有相关权限。之前在项目中尝试反射其他方法的时候还遇到过有权限和没权限返回的值不一样的情况。如果源码中明确进行了权限验证，而你的应用又无法获得这个权限的话，建议就不要反射了。 参考文献《Java核心技术》 \\Java高级特性——反射 \\认识反射机制（Reflection） \\Java 反射机制","pubDate":"Wed, 10 Apr 2019 02:30:24 GMT","guid":"https://lingyue9.github.io/2019/04/10/Java反射/","category":""},{"title":"我的第一篇博客文章","link":"https://lingyue9.github.io/2019/03/21/我的第一篇博客文章/","description":"制作自己的博客使用hexo制作了自己的个人博客，感谢CodeSheep的指导，了解了使用了node.js下使用hexo搭建博客的方法。 参考文献CodeSheep · 程序羊","pubDate":"Thu, 21 Mar 2019 02:30:24 GMT","guid":"https://lingyue9.github.io/2019/03/21/我的第一篇博客文章/","category":""}]}